// @generated by protoc-gen-es v2.2.3 with parameter "target=ts"
// @generated from file flow/executiondata/executiondata.proto (package flow.executiondata, syntax proto3)

import type {
  GenFile,
  GenMessage,
  GenService,
} from "@bufbuild/protobuf/codegenv1"
import {
  fileDesc,
  messageDesc,
  serviceDesc,
} from "@bufbuild/protobuf/codegenv1"
import type { BlockExecutionData } from "../entities/block_execution_data_pb"
import { file_flow_entities_block_execution_data } from "../entities/block_execution_data_pb"
import type { Event, EventEncodingVersion } from "../entities/event_pb"
import { file_flow_entities_event } from "../entities/event_pb"
import type { RegisterID } from "../entities/register_pb"
import { file_flow_entities_register } from "../entities/register_pb"
import type { Timestamp } from "@bufbuild/protobuf/wkt"
import { file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt"
import type { Message } from "@bufbuild/protobuf"

/**
 * Describes the file flow/executiondata/executiondata.proto.
 */
export const file_flow_executiondata_executiondata: GenFile =
  /*@__PURE__*/
  fileDesc(
    "CiZmbG93L2V4ZWN1dGlvbmRhdGEvZXhlY3V0aW9uZGF0YS5wcm90bxISZmxvdy5leGVjdXRpb25kYXRhInkKIEdldEV4ZWN1dGlvbkRhdGFCeUJsb2NrSURSZXF1ZXN0EhAKCGJsb2NrX2lkGAEgASgMEkMKFmV2ZW50X2VuY29kaW5nX3ZlcnNpb24YAiABKA4yIy5mbG93LmVudGl0aWVzLkV2ZW50RW5jb2RpbmdWZXJzaW9uImQKIUdldEV4ZWN1dGlvbkRhdGFCeUJsb2NrSURSZXNwb25zZRI/ChRibG9ja19leGVjdXRpb25fZGF0YRgBIAEoCzIhLmZsb3cuZW50aXRpZXMuQmxvY2tFeGVjdXRpb25EYXRhIpgBCh1TdWJzY3JpYmVFeGVjdXRpb25EYXRhUmVxdWVzdBIWCg5zdGFydF9ibG9ja19pZBgBIAEoDBIaChJzdGFydF9ibG9ja19oZWlnaHQYAiABKAQSQwoWZXZlbnRfZW5jb2RpbmdfdmVyc2lvbhgDIAEoDjIjLmZsb3cuZW50aXRpZXMuRXZlbnRFbmNvZGluZ1ZlcnNpb24irAEKHlN1YnNjcmliZUV4ZWN1dGlvbkRhdGFSZXNwb25zZRIUCgxibG9ja19oZWlnaHQYASABKAQSPwoUYmxvY2tfZXhlY3V0aW9uX2RhdGEYAiABKAsyIS5mbG93LmVudGl0aWVzLkJsb2NrRXhlY3V0aW9uRGF0YRIzCg9ibG9ja190aW1lc3RhbXAYAyABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wIowBCi1TdWJzY3JpYmVFeGVjdXRpb25EYXRhRnJvbVN0YXJ0QmxvY2tJRFJlcXVlc3QSFgoOc3RhcnRfYmxvY2tfaWQYASABKAwSQwoWZXZlbnRfZW5jb2RpbmdfdmVyc2lvbhgCIAEoDjIjLmZsb3cuZW50aXRpZXMuRXZlbnRFbmNvZGluZ1ZlcnNpb24ilAEKMVN1YnNjcmliZUV4ZWN1dGlvbkRhdGFGcm9tU3RhcnRCbG9ja0hlaWdodFJlcXVlc3QSGgoSc3RhcnRfYmxvY2tfaGVpZ2h0GAEgASgEEkMKFmV2ZW50X2VuY29kaW5nX3ZlcnNpb24YAiABKA4yIy5mbG93LmVudGl0aWVzLkV2ZW50RW5jb2RpbmdWZXJzaW9uIm4KJ1N1YnNjcmliZUV4ZWN1dGlvbkRhdGFGcm9tTGF0ZXN0UmVxdWVzdBJDChZldmVudF9lbmNvZGluZ192ZXJzaW9uGAEgASgOMiMuZmxvdy5lbnRpdGllcy5FdmVudEVuY29kaW5nVmVyc2lvbiLeAQoWU3Vic2NyaWJlRXZlbnRzUmVxdWVzdBIWCg5zdGFydF9ibG9ja19pZBgBIAEoDBIaChJzdGFydF9ibG9ja19oZWlnaHQYAiABKAQSLwoGZmlsdGVyGAMgASgLMh8uZmxvdy5leGVjdXRpb25kYXRhLkV2ZW50RmlsdGVyEhoKEmhlYXJ0YmVhdF9pbnRlcnZhbBgEIAEoBBJDChZldmVudF9lbmNvZGluZ192ZXJzaW9uGAUgASgOMiMuZmxvdy5lbnRpdGllcy5FdmVudEVuY29kaW5nVmVyc2lvbiLSAQomU3Vic2NyaWJlRXZlbnRzRnJvbVN0YXJ0QmxvY2tJRFJlcXVlc3QSFgoOc3RhcnRfYmxvY2tfaWQYASABKAwSLwoGZmlsdGVyGAIgASgLMh8uZmxvdy5leGVjdXRpb25kYXRhLkV2ZW50RmlsdGVyEhoKEmhlYXJ0YmVhdF9pbnRlcnZhbBgDIAEoBBJDChZldmVudF9lbmNvZGluZ192ZXJzaW9uGAQgASgOMiMuZmxvdy5lbnRpdGllcy5FdmVudEVuY29kaW5nVmVyc2lvbiLVAQolU3Vic2NyaWJlRXZlbnRzRnJvbVN0YXJ0SGVpZ2h0UmVxdWVzdBIaChJzdGFydF9ibG9ja19oZWlnaHQYASABKAQSLwoGZmlsdGVyGAIgASgLMh8uZmxvdy5leGVjdXRpb25kYXRhLkV2ZW50RmlsdGVyEhoKEmhlYXJ0YmVhdF9pbnRlcnZhbBgDIAEoBBJDChZldmVudF9lbmNvZGluZ192ZXJzaW9uGAQgASgOMiMuZmxvdy5lbnRpdGllcy5FdmVudEVuY29kaW5nVmVyc2lvbiK0AQogU3Vic2NyaWJlRXZlbnRzRnJvbUxhdGVzdFJlcXVlc3QSLwoGZmlsdGVyGAEgASgLMh8uZmxvdy5leGVjdXRpb25kYXRhLkV2ZW50RmlsdGVyEhoKEmhlYXJ0YmVhdF9pbnRlcnZhbBgCIAEoBBJDChZldmVudF9lbmNvZGluZ192ZXJzaW9uGAMgASgOMiMuZmxvdy5lbnRpdGllcy5FdmVudEVuY29kaW5nVmVyc2lvbiKzAQoXU3Vic2NyaWJlRXZlbnRzUmVzcG9uc2USEAoIYmxvY2tfaWQYASABKAwSFAoMYmxvY2tfaGVpZ2h0GAIgASgEEiQKBmV2ZW50cxgDIAMoCzIULmZsb3cuZW50aXRpZXMuRXZlbnQSMwoPYmxvY2tfdGltZXN0YW1wGAQgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIVCg1tZXNzYWdlX2luZGV4GAUgASgEIkQKC0V2ZW50RmlsdGVyEhIKCmV2ZW50X3R5cGUYASADKAkSEAoIY29udHJhY3QYAiADKAkSDwoHYWRkcmVzcxgDIAMoCSJhChhHZXRSZWdpc3RlclZhbHVlc1JlcXVlc3QSFAoMYmxvY2tfaGVpZ2h0GAEgASgEEi8KDHJlZ2lzdGVyX2lkcxgCIAMoCzIZLmZsb3cuZW50aXRpZXMuUmVnaXN0ZXJJRCIrChlHZXRSZWdpc3RlclZhbHVlc1Jlc3BvbnNlEg4KBnZhbHVlcxgBIAMoDCLcAQovU3Vic2NyaWJlQWNjb3VudFN0YXR1c2VzRnJvbVN0YXJ0QmxvY2tJRFJlcXVlc3QSFgoOc3RhcnRfYmxvY2tfaWQYASABKAwSMAoGZmlsdGVyGAIgASgLMiAuZmxvdy5leGVjdXRpb25kYXRhLlN0YXR1c0ZpbHRlchIaChJoZWFydGJlYXRfaW50ZXJ2YWwYAyABKAQSQwoWZXZlbnRfZW5jb2RpbmdfdmVyc2lvbhgEIAEoDjIjLmZsb3cuZW50aXRpZXMuRXZlbnRFbmNvZGluZ1ZlcnNpb24i3wEKLlN1YnNjcmliZUFjY291bnRTdGF0dXNlc0Zyb21TdGFydEhlaWdodFJlcXVlc3QSGgoSc3RhcnRfYmxvY2tfaGVpZ2h0GAEgASgEEjAKBmZpbHRlchgCIAEoCzIgLmZsb3cuZXhlY3V0aW9uZGF0YS5TdGF0dXNGaWx0ZXISGgoSaGVhcnRiZWF0X2ludGVydmFsGAMgASgEEkMKFmV2ZW50X2VuY29kaW5nX3ZlcnNpb24YBCABKA4yIy5mbG93LmVudGl0aWVzLkV2ZW50RW5jb2RpbmdWZXJzaW9uIsMBCi5TdWJzY3JpYmVBY2NvdW50U3RhdHVzZXNGcm9tTGF0ZXN0QmxvY2tSZXF1ZXN0EjAKBmZpbHRlchgBIAEoCzIgLmZsb3cuZXhlY3V0aW9uZGF0YS5TdGF0dXNGaWx0ZXISGgoSaGVhcnRiZWF0X2ludGVydmFsGAIgASgEEkMKFmV2ZW50X2VuY29kaW5nX3ZlcnNpb24YAyABKA4yIy5mbG93LmVudGl0aWVzLkV2ZW50RW5jb2RpbmdWZXJzaW9uIvABCiBTdWJzY3JpYmVBY2NvdW50U3RhdHVzZXNSZXNwb25zZRIQCghibG9ja19pZBgBIAEoDBIUCgxibG9ja19oZWlnaHQYAiABKAQSFQoNbWVzc2FnZV9pbmRleBgDIAEoBBJMCgdyZXN1bHRzGAQgAygLMjsuZmxvdy5leGVjdXRpb25kYXRhLlN1YnNjcmliZUFjY291bnRTdGF0dXNlc1Jlc3BvbnNlLlJlc3VsdBo/CgZSZXN1bHQSDwoHYWRkcmVzcxgBIAEoDBIkCgZldmVudHMYAiADKAsyFC5mbG93LmVudGl0aWVzLkV2ZW50IjMKDFN0YXR1c0ZpbHRlchISCgpldmVudF90eXBlGAEgAygJEg8KB2FkZHJlc3MYAyADKAkyjA8KEEV4ZWN1dGlvbkRhdGFBUEkSiAEKGUdldEV4ZWN1dGlvbkRhdGFCeUJsb2NrSUQSNC5mbG93LmV4ZWN1dGlvbmRhdGEuR2V0RXhlY3V0aW9uRGF0YUJ5QmxvY2tJRFJlcXVlc3QaNS5mbG93LmV4ZWN1dGlvbmRhdGEuR2V0RXhlY3V0aW9uRGF0YUJ5QmxvY2tJRFJlc3BvbnNlEoYBChZTdWJzY3JpYmVFeGVjdXRpb25EYXRhEjEuZmxvdy5leGVjdXRpb25kYXRhLlN1YnNjcmliZUV4ZWN1dGlvbkRhdGFSZXF1ZXN0GjIuZmxvdy5leGVjdXRpb25kYXRhLlN1YnNjcmliZUV4ZWN1dGlvbkRhdGFSZXNwb25zZSIDiAIBMAESoQEKJlN1YnNjcmliZUV4ZWN1dGlvbkRhdGFGcm9tU3RhcnRCbG9ja0lEEkEuZmxvdy5leGVjdXRpb25kYXRhLlN1YnNjcmliZUV4ZWN1dGlvbkRhdGFGcm9tU3RhcnRCbG9ja0lEUmVxdWVzdBoyLmZsb3cuZXhlY3V0aW9uZGF0YS5TdWJzY3JpYmVFeGVjdXRpb25EYXRhUmVzcG9uc2UwARKpAQoqU3Vic2NyaWJlRXhlY3V0aW9uRGF0YUZyb21TdGFydEJsb2NrSGVpZ2h0EkUuZmxvdy5leGVjdXRpb25kYXRhLlN1YnNjcmliZUV4ZWN1dGlvbkRhdGFGcm9tU3RhcnRCbG9ja0hlaWdodFJlcXVlc3QaMi5mbG93LmV4ZWN1dGlvbmRhdGEuU3Vic2NyaWJlRXhlY3V0aW9uRGF0YVJlc3BvbnNlMAESlQEKIFN1YnNjcmliZUV4ZWN1dGlvbkRhdGFGcm9tTGF0ZXN0EjsuZmxvdy5leGVjdXRpb25kYXRhLlN1YnNjcmliZUV4ZWN1dGlvbkRhdGFGcm9tTGF0ZXN0UmVxdWVzdBoyLmZsb3cuZXhlY3V0aW9uZGF0YS5TdWJzY3JpYmVFeGVjdXRpb25EYXRhUmVzcG9uc2UwARJxCg9TdWJzY3JpYmVFdmVudHMSKi5mbG93LmV4ZWN1dGlvbmRhdGEuU3Vic2NyaWJlRXZlbnRzUmVxdWVzdBorLmZsb3cuZXhlY3V0aW9uZGF0YS5TdWJzY3JpYmVFdmVudHNSZXNwb25zZSIDiAIBMAESjAEKH1N1YnNjcmliZUV2ZW50c0Zyb21TdGFydEJsb2NrSUQSOi5mbG93LmV4ZWN1dGlvbmRhdGEuU3Vic2NyaWJlRXZlbnRzRnJvbVN0YXJ0QmxvY2tJRFJlcXVlc3QaKy5mbG93LmV4ZWN1dGlvbmRhdGEuU3Vic2NyaWJlRXZlbnRzUmVzcG9uc2UwARKKAQoeU3Vic2NyaWJlRXZlbnRzRnJvbVN0YXJ0SGVpZ2h0EjkuZmxvdy5leGVjdXRpb25kYXRhLlN1YnNjcmliZUV2ZW50c0Zyb21TdGFydEhlaWdodFJlcXVlc3QaKy5mbG93LmV4ZWN1dGlvbmRhdGEuU3Vic2NyaWJlRXZlbnRzUmVzcG9uc2UwARKAAQoZU3Vic2NyaWJlRXZlbnRzRnJvbUxhdGVzdBI0LmZsb3cuZXhlY3V0aW9uZGF0YS5TdWJzY3JpYmVFdmVudHNGcm9tTGF0ZXN0UmVxdWVzdBorLmZsb3cuZXhlY3V0aW9uZGF0YS5TdWJzY3JpYmVFdmVudHNSZXNwb25zZTABEnAKEUdldFJlZ2lzdGVyVmFsdWVzEiwuZmxvdy5leGVjdXRpb25kYXRhLkdldFJlZ2lzdGVyVmFsdWVzUmVxdWVzdBotLmZsb3cuZXhlY3V0aW9uZGF0YS5HZXRSZWdpc3RlclZhbHVlc1Jlc3BvbnNlEqcBCihTdWJzY3JpYmVBY2NvdW50U3RhdHVzZXNGcm9tU3RhcnRCbG9ja0lEEkMuZmxvdy5leGVjdXRpb25kYXRhLlN1YnNjcmliZUFjY291bnRTdGF0dXNlc0Zyb21TdGFydEJsb2NrSURSZXF1ZXN0GjQuZmxvdy5leGVjdXRpb25kYXRhLlN1YnNjcmliZUFjY291bnRTdGF0dXNlc1Jlc3BvbnNlMAESpQEKJ1N1YnNjcmliZUFjY291bnRTdGF0dXNlc0Zyb21TdGFydEhlaWdodBJCLmZsb3cuZXhlY3V0aW9uZGF0YS5TdWJzY3JpYmVBY2NvdW50U3RhdHVzZXNGcm9tU3RhcnRIZWlnaHRSZXF1ZXN0GjQuZmxvdy5leGVjdXRpb25kYXRhLlN1YnNjcmliZUFjY291bnRTdGF0dXNlc1Jlc3BvbnNlMAESpQEKJ1N1YnNjcmliZUFjY291bnRTdGF0dXNlc0Zyb21MYXRlc3RCbG9jaxJCLmZsb3cuZXhlY3V0aW9uZGF0YS5TdWJzY3JpYmVBY2NvdW50U3RhdHVzZXNGcm9tTGF0ZXN0QmxvY2tSZXF1ZXN0GjQuZmxvdy5leGVjdXRpb25kYXRhLlN1YnNjcmliZUFjY291bnRTdGF0dXNlc1Jlc3BvbnNlMAFCWgohb3JnLm9uZmxvdy5wcm90b2J1Zi5leGVjdXRpb25kYXRhWjVnaXRodWIuY29tL29uZmxvdy9mbG93L3Byb3RvYnVmL2dvL2Zsb3cvZXhlY3V0aW9uZGF0YWIGcHJvdG8z",
    [
      file_flow_entities_block_execution_data,
      file_flow_entities_event,
      file_flow_entities_register,
      file_google_protobuf_timestamp,
    ],
  )

/**
 * The request for GetExecutionDataByBlockID
 *
 * @generated from message flow.executiondata.GetExecutionDataByBlockIDRequest
 */
export type GetExecutionDataByBlockIDRequest =
  Message<"flow.executiondata.GetExecutionDataByBlockIDRequest"> & {
    /**
     * Block ID of the block to get execution data for.
     *
     * @generated from field: bytes block_id = 1;
     */
    blockId: Uint8Array

    /**
     * Preferred event encoding version of the block events payload.
     * Possible variants:
     * 1. CCF
     * 2. JSON-CDC
     *
     * @generated from field: flow.entities.EventEncodingVersion event_encoding_version = 2;
     */
    eventEncodingVersion: EventEncodingVersion
  }

/**
 * Describes the message flow.executiondata.GetExecutionDataByBlockIDRequest.
 * Use `create(GetExecutionDataByBlockIDRequestSchema)` to create a new message.
 */
export const GetExecutionDataByBlockIDRequestSchema: GenMessage<GetExecutionDataByBlockIDRequest> =
  /*@__PURE__*/
  messageDesc(file_flow_executiondata_executiondata, 0)

/**
 * The response for GetExecutionDataByBlockID
 *
 * @generated from message flow.executiondata.GetExecutionDataByBlockIDResponse
 */
export type GetExecutionDataByBlockIDResponse =
  Message<"flow.executiondata.GetExecutionDataByBlockIDResponse"> & {
    /**
     * BlockExecutionData for the block.
     *
     * @generated from field: flow.entities.BlockExecutionData block_execution_data = 1;
     */
    blockExecutionData?: BlockExecutionData
  }

/**
 * Describes the message flow.executiondata.GetExecutionDataByBlockIDResponse.
 * Use `create(GetExecutionDataByBlockIDResponseSchema)` to create a new message.
 */
export const GetExecutionDataByBlockIDResponseSchema: GenMessage<GetExecutionDataByBlockIDResponse> =
  /*@__PURE__*/
  messageDesc(file_flow_executiondata_executiondata, 1)

/**
 * The request for SubscribeExecutionData
 *
 * @generated from message flow.executiondata.SubscribeExecutionDataRequest
 */
export type SubscribeExecutionDataRequest =
  Message<"flow.executiondata.SubscribeExecutionDataRequest"> & {
    /**
     * Block ID of the first block to get execution data for.
     * Only one of start_block_id and start_block_height may be provided,
     * otherwise an InvalidArgument error is returned. If neither are provided,
     * the latest sealed block is used.
     *
     * @generated from field: bytes start_block_id = 1;
     */
    startBlockId: Uint8Array

    /**
     * Block height of the first block to get execution data for.
     * Only one of start_block_id and start_block_height may be provided,
     * otherwise an InvalidArgument error is returned. If neither are provided,
     * the latest sealed block is used.
     *
     * @generated from field: uint64 start_block_height = 2;
     */
    startBlockHeight: bigint

    /**
     * Preferred event encoding version of the block events payload.
     * Possible variants:
     * 1. CCF
     * 2. JSON-CDC
     *
     * @generated from field: flow.entities.EventEncodingVersion event_encoding_version = 3;
     */
    eventEncodingVersion: EventEncodingVersion
  }

/**
 * Describes the message flow.executiondata.SubscribeExecutionDataRequest.
 * Use `create(SubscribeExecutionDataRequestSchema)` to create a new message.
 */
export const SubscribeExecutionDataRequestSchema: GenMessage<SubscribeExecutionDataRequest> =
  /*@__PURE__*/
  messageDesc(file_flow_executiondata_executiondata, 2)

/**
 * The response for SubscribeExecutionData
 *
 * @generated from message flow.executiondata.SubscribeExecutionDataResponse
 */
export type SubscribeExecutionDataResponse =
  Message<"flow.executiondata.SubscribeExecutionDataResponse"> & {
    /**
     * Block height of the block containing the execution data.
     *
     * @generated from field: uint64 block_height = 1;
     */
    blockHeight: bigint

    /**
     * BlockExecutionData for the block.
     * Note: The block's ID is included within the BlockExecutionData.
     *
     * @generated from field: flow.entities.BlockExecutionData block_execution_data = 2;
     */
    blockExecutionData?: BlockExecutionData

    /**
     * Timestamp from the block containing the execution data.
     *
     * @generated from field: google.protobuf.Timestamp block_timestamp = 3;
     */
    blockTimestamp?: Timestamp
  }

/**
 * Describes the message flow.executiondata.SubscribeExecutionDataResponse.
 * Use `create(SubscribeExecutionDataResponseSchema)` to create a new message.
 */
export const SubscribeExecutionDataResponseSchema: GenMessage<SubscribeExecutionDataResponse> =
  /*@__PURE__*/
  messageDesc(file_flow_executiondata_executiondata, 3)

/**
 * The request for SubscribeExecutionDataFromStartBlockIDRequest
 *
 * @generated from message flow.executiondata.SubscribeExecutionDataFromStartBlockIDRequest
 */
export type SubscribeExecutionDataFromStartBlockIDRequest =
  Message<"flow.executiondata.SubscribeExecutionDataFromStartBlockIDRequest"> & {
    /**
     * Block ID of the first block to get execution data for.
     *
     * @generated from field: bytes start_block_id = 1;
     */
    startBlockId: Uint8Array

    /**
     * Preferred event encoding version of the block events payload.
     * Possible variants:
     * 1. CCF
     * 2. JSON-CDC
     *
     * @generated from field: flow.entities.EventEncodingVersion event_encoding_version = 2;
     */
    eventEncodingVersion: EventEncodingVersion
  }

/**
 * Describes the message flow.executiondata.SubscribeExecutionDataFromStartBlockIDRequest.
 * Use `create(SubscribeExecutionDataFromStartBlockIDRequestSchema)` to create a new message.
 */
export const SubscribeExecutionDataFromStartBlockIDRequestSchema: GenMessage<SubscribeExecutionDataFromStartBlockIDRequest> =
  /*@__PURE__*/
  messageDesc(file_flow_executiondata_executiondata, 4)

/**
 * The request for SubscribeExecutionDataFromStartBlockHeightRequest
 *
 * @generated from message flow.executiondata.SubscribeExecutionDataFromStartBlockHeightRequest
 */
export type SubscribeExecutionDataFromStartBlockHeightRequest =
  Message<"flow.executiondata.SubscribeExecutionDataFromStartBlockHeightRequest"> & {
    /**
     * Block height of the first block to get execution data for.
     *
     * @generated from field: uint64 start_block_height = 1;
     */
    startBlockHeight: bigint

    /**
     * Preferred event encoding version of the block events payload.
     * Possible variants:
     * 1. CCF
     * 2. JSON-CDC
     *
     * @generated from field: flow.entities.EventEncodingVersion event_encoding_version = 2;
     */
    eventEncodingVersion: EventEncodingVersion
  }

/**
 * Describes the message flow.executiondata.SubscribeExecutionDataFromStartBlockHeightRequest.
 * Use `create(SubscribeExecutionDataFromStartBlockHeightRequestSchema)` to create a new message.
 */
export const SubscribeExecutionDataFromStartBlockHeightRequestSchema: GenMessage<SubscribeExecutionDataFromStartBlockHeightRequest> =
  /*@__PURE__*/
  messageDesc(file_flow_executiondata_executiondata, 5)

/**
 * The request for SubscribeExecutionDataFromLatestRequest
 *
 * @generated from message flow.executiondata.SubscribeExecutionDataFromLatestRequest
 */
export type SubscribeExecutionDataFromLatestRequest =
  Message<"flow.executiondata.SubscribeExecutionDataFromLatestRequest"> & {
    /**
     * Preferred event encoding version of the block events payload.
     * Possible variants:
     * 1. CCF
     * 2. JSON-CDC
     *
     * @generated from field: flow.entities.EventEncodingVersion event_encoding_version = 1;
     */
    eventEncodingVersion: EventEncodingVersion
  }

/**
 * Describes the message flow.executiondata.SubscribeExecutionDataFromLatestRequest.
 * Use `create(SubscribeExecutionDataFromLatestRequestSchema)` to create a new message.
 */
export const SubscribeExecutionDataFromLatestRequestSchema: GenMessage<SubscribeExecutionDataFromLatestRequest> =
  /*@__PURE__*/
  messageDesc(file_flow_executiondata_executiondata, 6)

/**
 * The request for SubscribeEvents
 *
 * @generated from message flow.executiondata.SubscribeEventsRequest
 */
export type SubscribeEventsRequest =
  Message<"flow.executiondata.SubscribeEventsRequest"> & {
    /**
     * Block ID of the first block to search for events.
     * Only one of start_block_id and start_block_height may be provided,
     * otherwise an InvalidArgument error is returned. If neither are provided,
     * the latest sealed block is used.
     *
     * @generated from field: bytes start_block_id = 1;
     */
    startBlockId: Uint8Array

    /**
     * Block height of the first block to search for events.
     * Only one of start_block_id and start_block_height may be provided,
     * otherwise an InvalidArgument error is returned. If neither are provided,
     * the latest sealed block is used.
     *
     * @generated from field: uint64 start_block_height = 2;
     */
    startBlockHeight: bigint

    /**
     * Filter to apply to events for each block searched.
     * If no filter is provided, all events are returned.
     *
     * @generated from field: flow.executiondata.EventFilter filter = 3;
     */
    filter?: EventFilter

    /**
     * Interval in block heights at which the server should return a heartbeat
     * message to the client. The heartbeat is a normal SubscribeEventsResponse
     * with no events, and allows clients to track which blocks were searched.
     * Clients can use this information to determine which block to start from
     * when reconnecting.
     *
     * The interval is calculated from the last response returned, which could be
     * either another heartbeat or a response containing events.
     *
     * @generated from field: uint64 heartbeat_interval = 4;
     */
    heartbeatInterval: bigint

    /**
     * Preferred event encoding version of the block events payload.
     * Possible variants:
     * 1. CCF
     * 2. JSON-CDC
     *
     * @generated from field: flow.entities.EventEncodingVersion event_encoding_version = 5;
     */
    eventEncodingVersion: EventEncodingVersion
  }

/**
 * Describes the message flow.executiondata.SubscribeEventsRequest.
 * Use `create(SubscribeEventsRequestSchema)` to create a new message.
 */
export const SubscribeEventsRequestSchema: GenMessage<SubscribeEventsRequest> =
  /*@__PURE__*/
  messageDesc(file_flow_executiondata_executiondata, 7)

/**
 * The request for SubscribeEventsFromStartBlockID
 *
 * @generated from message flow.executiondata.SubscribeEventsFromStartBlockIDRequest
 */
export type SubscribeEventsFromStartBlockIDRequest =
  Message<"flow.executiondata.SubscribeEventsFromStartBlockIDRequest"> & {
    /**
     * Block ID of the first block to search for events.
     *
     * @generated from field: bytes start_block_id = 1;
     */
    startBlockId: Uint8Array

    /**
     * Filter to apply to events for each block searched.
     * If no filter is provided, all events are returned.
     *
     * @generated from field: flow.executiondata.EventFilter filter = 2;
     */
    filter?: EventFilter

    /**
     * Interval in block heights at which the server should return a heartbeat
     * message to the client. The heartbeat is a normal SubscribeEventsResponse
     * with no events, and allows clients to track which blocks were searched.
     * Clients can use this information to determine which block to start from
     * when reconnecting.
     *
     * The interval is calculated from the last response returned, which could be
     * either another heartbeat or a response containing events.
     *
     * @generated from field: uint64 heartbeat_interval = 3;
     */
    heartbeatInterval: bigint

    /**
     * Preferred event encoding version of the block events payload.
     * Possible variants:
     * 1. CCF
     * 2. JSON-CDC
     *
     * @generated from field: flow.entities.EventEncodingVersion event_encoding_version = 4;
     */
    eventEncodingVersion: EventEncodingVersion
  }

/**
 * Describes the message flow.executiondata.SubscribeEventsFromStartBlockIDRequest.
 * Use `create(SubscribeEventsFromStartBlockIDRequestSchema)` to create a new message.
 */
export const SubscribeEventsFromStartBlockIDRequestSchema: GenMessage<SubscribeEventsFromStartBlockIDRequest> =
  /*@__PURE__*/
  messageDesc(file_flow_executiondata_executiondata, 8)

/**
 * The request for SubscribeEventsFromStartHeight
 *
 * @generated from message flow.executiondata.SubscribeEventsFromStartHeightRequest
 */
export type SubscribeEventsFromStartHeightRequest =
  Message<"flow.executiondata.SubscribeEventsFromStartHeightRequest"> & {
    /**
     * Block height of the first block to search for events.
     *
     * @generated from field: uint64 start_block_height = 1;
     */
    startBlockHeight: bigint

    /**
     * Filter to apply to events for each block searched.
     * If no filter is provided, all events are returned.
     *
     * @generated from field: flow.executiondata.EventFilter filter = 2;
     */
    filter?: EventFilter

    /**
     * Interval in block heights at which the server should return a heartbeat
     * message to the client. The heartbeat is a normal SubscribeEventsResponse
     * with no events, and allows clients to track which blocks were searched.
     * Clients can use this information to determine which block to start from
     * when reconnecting.
     *
     * The interval is calculated from the last response returned, which could be
     * either another heartbeat or a response containing events.
     *
     * @generated from field: uint64 heartbeat_interval = 3;
     */
    heartbeatInterval: bigint

    /**
     * Preferred event encoding version of the block events payload.
     * Possible variants:
     * 1. CCF
     * 2. JSON-CDC
     *
     * @generated from field: flow.entities.EventEncodingVersion event_encoding_version = 4;
     */
    eventEncodingVersion: EventEncodingVersion
  }

/**
 * Describes the message flow.executiondata.SubscribeEventsFromStartHeightRequest.
 * Use `create(SubscribeEventsFromStartHeightRequestSchema)` to create a new message.
 */
export const SubscribeEventsFromStartHeightRequestSchema: GenMessage<SubscribeEventsFromStartHeightRequest> =
  /*@__PURE__*/
  messageDesc(file_flow_executiondata_executiondata, 9)

/**
 * The request for SubscribeEventsFromLatest
 *
 * @generated from message flow.executiondata.SubscribeEventsFromLatestRequest
 */
export type SubscribeEventsFromLatestRequest =
  Message<"flow.executiondata.SubscribeEventsFromLatestRequest"> & {
    /**
     * Filter to apply to events for each block searched.
     * If no filter is provided, all events are returned.
     *
     * @generated from field: flow.executiondata.EventFilter filter = 1;
     */
    filter?: EventFilter

    /**
     * Interval in block heights at which the server should return a heartbeat
     * message to the client. The heartbeat is a normal SubscribeEventsResponse
     * with no events, and allows clients to track which blocks were searched.
     * Clients can use this information to determine which block to start from
     * when reconnecting.
     *
     * The interval is calculated from the last response returned, which could be
     * either another heartbeat or a response containing events.
     *
     * @generated from field: uint64 heartbeat_interval = 2;
     */
    heartbeatInterval: bigint

    /**
     * Preferred event encoding version of the block events payload.
     * Possible variants:
     * 1. CCF
     * 2. JSON-CDC
     *
     * @generated from field: flow.entities.EventEncodingVersion event_encoding_version = 3;
     */
    eventEncodingVersion: EventEncodingVersion
  }

/**
 * Describes the message flow.executiondata.SubscribeEventsFromLatestRequest.
 * Use `create(SubscribeEventsFromLatestRequestSchema)` to create a new message.
 */
export const SubscribeEventsFromLatestRequestSchema: GenMessage<SubscribeEventsFromLatestRequest> =
  /*@__PURE__*/
  messageDesc(file_flow_executiondata_executiondata, 10)

/**
 * The response for SubscribeEvents
 *
 * @generated from message flow.executiondata.SubscribeEventsResponse
 */
export type SubscribeEventsResponse =
  Message<"flow.executiondata.SubscribeEventsResponse"> & {
    /**
     * Block ID of the block containing the events.
     *
     * @generated from field: bytes block_id = 1;
     */
    blockId: Uint8Array

    /**
     * Block height of the block containing the events.
     *
     * @generated from field: uint64 block_height = 2;
     */
    blockHeight: bigint

    /**
     * Events matching the EventFilter in the request.
     * The API may return no events which signals a periodic heartbeat. This
     * allows clients to track which blocks were searched. Client can use this
     * information to determine which block to start from when reconnecting.
     *
     * @generated from field: repeated flow.entities.Event events = 3;
     */
    events: Event[]

    /**
     * Timestamp from the block containing the events.
     *
     * @generated from field: google.protobuf.Timestamp block_timestamp = 4;
     */
    blockTimestamp?: Timestamp

    /**
     * The message index of the response message. Used by the client to ensure they received all messages. Starts from "0".
     *
     * @generated from field: uint64 message_index = 5;
     */
    messageIndex: bigint
  }

/**
 * Describes the message flow.executiondata.SubscribeEventsResponse.
 * Use `create(SubscribeEventsResponseSchema)` to create a new message.
 */
export const SubscribeEventsResponseSchema: GenMessage<SubscribeEventsResponse> =
  /*@__PURE__*/
  messageDesc(file_flow_executiondata_executiondata, 11)

/**
 * EventFilter defines the filter to apply to block events.
 * Filters are applied as an OR operation, i.e. any event matching any of the
 * filters is returned. If no filters are provided, all events are returned. If
 * there are any invalid filters, the API will return an InvalidArgument error.
 *
 * @generated from message flow.executiondata.EventFilter
 */
export type EventFilter = Message<"flow.executiondata.EventFilter"> & {
  /**
   * A list of full event types to include.
   *
   * All events exactly matching any of the provided event types will be
   * returned.
   *
   * Event types have 2 formats:
   * - Protocol events:
   *     flow.[event name]
   * - Smart contract events:
   *     A.[contract address].[contract name].[event name]
   *
   * @generated from field: repeated string event_type = 1;
   */
  eventType: string[]

  /**
   * A list of contracts who's events should be included.
   *
   * All events emitted by any of the provided contracts will be returned.
   *
   * Contracts have the following name formats:
   * - Protocol events:
   *     flow
   * - Smart contract events:
   *     A.[contract address].[contract name]
   *
   * This filter matches on the full contract including its address, not just
   * the contract's name.
   *
   * @generated from field: repeated string contract = 2;
   */
  contract: string[]

  /**
   * A list of addresses who's events should be included.
   *
   * All events emitted by any contract held by any of the provided addresses
   * will be returned.
   *
   * Addresses must be Flow account addresses in hex format and valid for the
   * network the node is connected to. i.e. only a mainnet address is valid for
   * a mainnet node. Addresses may optionally include the 0x prefix.
   *
   * @generated from field: repeated string address = 3;
   */
  address: string[]
}

/**
 * Describes the message flow.executiondata.EventFilter.
 * Use `create(EventFilterSchema)` to create a new message.
 */
export const EventFilterSchema: GenMessage<EventFilter> =
  /*@__PURE__*/
  messageDesc(file_flow_executiondata_executiondata, 12)

/**
 * request for GetRegisterValues
 *
 * @generated from message flow.executiondata.GetRegisterValuesRequest
 */
export type GetRegisterValuesRequest =
  Message<"flow.executiondata.GetRegisterValuesRequest"> & {
    /**
     * Block height of the execution state being queried.
     *
     * @generated from field: uint64 block_height = 1;
     */
    blockHeight: bigint

    /**
     * Register IDs of the Ledger.RegisterID format with an owner and key.
     *
     * @generated from field: repeated flow.entities.RegisterID register_ids = 2;
     */
    registerIds: RegisterID[]
  }

/**
 * Describes the message flow.executiondata.GetRegisterValuesRequest.
 * Use `create(GetRegisterValuesRequestSchema)` to create a new message.
 */
export const GetRegisterValuesRequestSchema: GenMessage<GetRegisterValuesRequest> =
  /*@__PURE__*/
  messageDesc(file_flow_executiondata_executiondata, 13)

/**
 * response for GetRegisterValues
 *
 * @generated from message flow.executiondata.GetRegisterValuesResponse
 */
export type GetRegisterValuesResponse =
  Message<"flow.executiondata.GetRegisterValuesResponse"> & {
    /**
     * raw register values at the given height.
     *
     * @generated from field: repeated bytes values = 1;
     */
    values: Uint8Array[]
  }

/**
 * Describes the message flow.executiondata.GetRegisterValuesResponse.
 * Use `create(GetRegisterValuesResponseSchema)` to create a new message.
 */
export const GetRegisterValuesResponseSchema: GenMessage<GetRegisterValuesResponse> =
  /*@__PURE__*/
  messageDesc(file_flow_executiondata_executiondata, 14)

/**
 * The request for SubscribeAccountStatusesFromStartBlockID
 *
 * @generated from message flow.executiondata.SubscribeAccountStatusesFromStartBlockIDRequest
 */
export type SubscribeAccountStatusesFromStartBlockIDRequest =
  Message<"flow.executiondata.SubscribeAccountStatusesFromStartBlockIDRequest"> & {
    /**
     * Block ID of the first block to search for events.
     * Only one of start_block_id and start_block_height may be provided,
     * otherwise an InvalidArgument error is returned. If neither are provided,
     * the latest sealed block is used.
     *
     * @generated from field: bytes start_block_id = 1;
     */
    startBlockId: Uint8Array

    /**
     * Filter to apply to events for each block searched.
     * If no filter is provided, all statuses are returned.
     *
     * @generated from field: flow.executiondata.StatusFilter filter = 2;
     */
    filter?: StatusFilter

    /**
     * Interval in block heights at which the server should return a heartbeat
     * message to the client. The heartbeat is a normal SubscribeAccountStatusesResponse
     * with no events, and allows clients to track which blocks were searched.
     * Clients can use this information to determine which block to start from
     * when reconnecting.
     *
     * The interval is calculated from the last response returned, which could be
     * either another heartbeat or a response containing events.
     *
     * @generated from field: uint64 heartbeat_interval = 3;
     */
    heartbeatInterval: bigint

    /**
     * Preferred event encoding version of the block events payload.
     * Possible variants:
     * 1. CCF
     * 2. JSON-CDC
     *
     * @generated from field: flow.entities.EventEncodingVersion event_encoding_version = 4;
     */
    eventEncodingVersion: EventEncodingVersion
  }

/**
 * Describes the message flow.executiondata.SubscribeAccountStatusesFromStartBlockIDRequest.
 * Use `create(SubscribeAccountStatusesFromStartBlockIDRequestSchema)` to create a new message.
 */
export const SubscribeAccountStatusesFromStartBlockIDRequestSchema: GenMessage<SubscribeAccountStatusesFromStartBlockIDRequest> =
  /*@__PURE__*/
  messageDesc(file_flow_executiondata_executiondata, 15)

/**
 * The request for SubscribeAccountStatusesFromStartHeight
 *
 * @generated from message flow.executiondata.SubscribeAccountStatusesFromStartHeightRequest
 */
export type SubscribeAccountStatusesFromStartHeightRequest =
  Message<"flow.executiondata.SubscribeAccountStatusesFromStartHeightRequest"> & {
    /**
     * Block height of the first block to search for events.
     * Only one of start_block_id and start_block_height may be provided,
     * otherwise an InvalidArgument error is returned. If neither are provided,
     * the latest sealed block is used.
     *
     * @generated from field: uint64 start_block_height = 1;
     */
    startBlockHeight: bigint

    /**
     * Filter to apply to events for each block searched.
     * If no filter is provided, all statuses are returned.
     *
     * @generated from field: flow.executiondata.StatusFilter filter = 2;
     */
    filter?: StatusFilter

    /**
     * Interval in block heights at which the server should return a heartbeat
     * message to the client. The heartbeat is a normal SubscribeAccountStatusesResponse
     * with no events, and allows clients to track which blocks were searched.
     * Clients can use this information to determine which block to start from
     * when reconnecting.
     *
     * The interval is calculated from the last response returned, which could be
     * either another heartbeat or a response containing events.
     *
     * @generated from field: uint64 heartbeat_interval = 3;
     */
    heartbeatInterval: bigint

    /**
     * Preferred event encoding version of the block events payload.
     * Possible variants:
     * 1. CCF
     * 2. JSON-CDC
     *
     * @generated from field: flow.entities.EventEncodingVersion event_encoding_version = 4;
     */
    eventEncodingVersion: EventEncodingVersion
  }

/**
 * Describes the message flow.executiondata.SubscribeAccountStatusesFromStartHeightRequest.
 * Use `create(SubscribeAccountStatusesFromStartHeightRequestSchema)` to create a new message.
 */
export const SubscribeAccountStatusesFromStartHeightRequestSchema: GenMessage<SubscribeAccountStatusesFromStartHeightRequest> =
  /*@__PURE__*/
  messageDesc(file_flow_executiondata_executiondata, 16)

/**
 * The request for SubscribeAccountStatusesFromLatestBlock
 *
 * @generated from message flow.executiondata.SubscribeAccountStatusesFromLatestBlockRequest
 */
export type SubscribeAccountStatusesFromLatestBlockRequest =
  Message<"flow.executiondata.SubscribeAccountStatusesFromLatestBlockRequest"> & {
    /**
     * Filter to apply to events for each block searched.
     * If no filter is provided, all statuses are returned.
     *
     * @generated from field: flow.executiondata.StatusFilter filter = 1;
     */
    filter?: StatusFilter

    /**
     * Interval in block heights at which the server should return a heartbeat
     * message to the client. The heartbeat is a normal SubscribeAccountStatusesResponse
     * with no events, and allows clients to track which blocks were searched.
     * Clients can use this information to determine which block to start from
     * when reconnecting.
     *
     * The interval is calculated from the last response returned, which could be
     * either another heartbeat or a response containing events.
     *
     * @generated from field: uint64 heartbeat_interval = 2;
     */
    heartbeatInterval: bigint

    /**
     * Preferred event encoding version of the block events payload.
     * Possible variants:
     * 1. CCF
     * 2. JSON-CDC
     *
     * @generated from field: flow.entities.EventEncodingVersion event_encoding_version = 3;
     */
    eventEncodingVersion: EventEncodingVersion
  }

/**
 * Describes the message flow.executiondata.SubscribeAccountStatusesFromLatestBlockRequest.
 * Use `create(SubscribeAccountStatusesFromLatestBlockRequestSchema)` to create a new message.
 */
export const SubscribeAccountStatusesFromLatestBlockRequestSchema: GenMessage<SubscribeAccountStatusesFromLatestBlockRequest> =
  /*@__PURE__*/
  messageDesc(file_flow_executiondata_executiondata, 17)

/**
 * The response for SubscribeAccountStatuses
 *
 * @generated from message flow.executiondata.SubscribeAccountStatusesResponse
 */
export type SubscribeAccountStatusesResponse =
  Message<"flow.executiondata.SubscribeAccountStatusesResponse"> & {
    /**
     * Block ID of the block containing the events.
     *
     * @generated from field: bytes block_id = 1;
     */
    blockId: Uint8Array

    /**
     * Block height of the block containing the events.
     *
     * @generated from field: uint64 block_height = 2;
     */
    blockHeight: bigint

    /**
     * The message index of the response message. Used by the client to ensure they received all messages. Starts from "0".
     *
     * @generated from field: uint64 message_index = 3;
     */
    messageIndex: bigint

    /**
     * The API may return no results which signals a periodic heartbeat. This
     * allows clients to track which blocks were searched. Client can use this
     * information to determine which block to start from when reconnecting.
     *
     * @generated from field: repeated flow.executiondata.SubscribeAccountStatusesResponse.Result results = 4;
     */
    results: SubscribeAccountStatusesResponse_Result[]
  }

/**
 * Describes the message flow.executiondata.SubscribeAccountStatusesResponse.
 * Use `create(SubscribeAccountStatusesResponseSchema)` to create a new message.
 */
export const SubscribeAccountStatusesResponseSchema: GenMessage<SubscribeAccountStatusesResponse> =
  /*@__PURE__*/
  messageDesc(file_flow_executiondata_executiondata, 18)

/**
 * @generated from message flow.executiondata.SubscribeAccountStatusesResponse.Result
 */
export type SubscribeAccountStatusesResponse_Result =
  Message<"flow.executiondata.SubscribeAccountStatusesResponse.Result"> & {
    /**
     * Unique identifier for the account being streamed
     *
     * @generated from field: bytes address = 1;
     */
    address: Uint8Array

    /**
     * Events matching the StatusFilter in the request.
     *
     * @generated from field: repeated flow.entities.Event events = 2;
     */
    events: Event[]
  }

/**
 * Describes the message flow.executiondata.SubscribeAccountStatusesResponse.Result.
 * Use `create(SubscribeAccountStatusesResponse_ResultSchema)` to create a new message.
 */
export const SubscribeAccountStatusesResponse_ResultSchema: GenMessage<SubscribeAccountStatusesResponse_Result> =
  /*@__PURE__*/
  messageDesc(file_flow_executiondata_executiondata, 18, 0)

/**
 * StatusesFilter defines the filter to apply to block events.
 * Filters match for events with types in the included event_type list, that are
 * related to at least one address from the provided address list. An event who's
 * type matches but address does not is ignored, and vice versa.
 * If no event_types are provided, all account related protocol event types are matched.
 * If no addresses are provided, any address matches.
 * If there are any invalid filters, the API will return an InvalidArgument error.
 *
 * @generated from message flow.executiondata.StatusFilter
 */
export type StatusFilter = Message<"flow.executiondata.StatusFilter"> & {
  /**
   * A list of full event types to include.
   *
   * All events exactly matching any of the provided event types will be
   * returned.
   *
   * Event types must be protocol events. e.g.
   *     flow.[event name]
   *
   * @generated from field: repeated string event_type = 1;
   */
  eventType: string[]

  /**
   * A list of addresses who's events should be included.
   *
   * All events matching the provided event_types that are related to any of the provided addresses
   * will be returned. If no addresses are provided, all events matching event_types will be returned.
   *
   * Addresses must be Flow account addresses in hex format and valid for the
   * network the node is connected to. i.e. only a mainnet address is valid for
   * a mainnet node. Addresses may optionally include the 0x prefix.
   *
   * @generated from field: repeated string address = 3;
   */
  address: string[]
}

/**
 * Describes the message flow.executiondata.StatusFilter.
 * Use `create(StatusFilterSchema)` to create a new message.
 */
export const StatusFilterSchema: GenMessage<StatusFilter> =
  /*@__PURE__*/
  messageDesc(file_flow_executiondata_executiondata, 19)

/**
 * Execution Data API provides access to execution data from the Flow network
 *
 * @generated from service flow.executiondata.ExecutionDataAPI
 */
export const ExecutionDataAPI: GenService<{
  /**
   * GetExecutionDataByBlockID returns execution data for a specific block ID.
   *
   * Errors:
   * - InvalidArgument is returned if the request contains an invalid block ID.
   * - NotFound is returned if the start block or execution data are not
   * currently available on the
   *   node. This may happen if the block was from a previous spork, or if the
   *   block has yet not been received.
   *
   * @generated from rpc flow.executiondata.ExecutionDataAPI.GetExecutionDataByBlockID
   */
  getExecutionDataByBlockID: {
    methodKind: "unary"
    input: typeof GetExecutionDataByBlockIDRequestSchema
    output: typeof GetExecutionDataByBlockIDResponseSchema
  }
  /**
   * Warning: this endpoint is deprecated and will be removed in future versions.
   * Use SubscribeExecutionDataFromStartBlockID, SubscribeExecutionDataFromStartBlockHeight
   * or SubscribeExecutionDataFromLatest.
   *
   * SubscribeExecutionData streams execution data for all blocks starting at
   * the requested start block, up until the latest available block. Once the
   * latest is reached, the stream will remain open and responses are sent for
   * each new execution data as it becomes available.
   *
   * Errors:
   * - InvalidArgument is returned if the request contains an invalid start
   * block.
   * - NotFound is returned if the start block is not currently available on the
   * node. This may happen if the block was from a previous spork, or if the block
   * has yet not been received.
   *
   * @generated from rpc flow.executiondata.ExecutionDataAPI.SubscribeExecutionData
   * @deprecated
   */
  subscribeExecutionData: {
    methodKind: "server_streaming"
    input: typeof SubscribeExecutionDataRequestSchema
    output: typeof SubscribeExecutionDataResponseSchema
  }
  /**
   * SubscribeExecutionDataFromStartBlockID streams execution data for all blocks
   * starting at the requested start block, up until the latest available block.
   * Once the latest is reached, the stream will remain open and responses are
   * sent for each new execution data as it becomes available.
   *
   * Errors:
   * - InvalidArgument is returned if the request contains an invalid start
   * block.
   * - NotFound is returned if the start block is not currently available on the
   * node. This may happen if the block was from a previous spork,
   * or if the block has yet not been received.
   *
   * @generated from rpc flow.executiondata.ExecutionDataAPI.SubscribeExecutionDataFromStartBlockID
   */
  subscribeExecutionDataFromStartBlockID: {
    methodKind: "server_streaming"
    input: typeof SubscribeExecutionDataFromStartBlockIDRequestSchema
    output: typeof SubscribeExecutionDataResponseSchema
  }
  /**
   * SubscribeExecutionDataFromStartBlockHeight streams execution data for all blocks
   * starting at the requested start block, up until the latest available block.
   * Once the latest is reached, the stream will remain open and responses are
   * sent for each new execution data as it becomes available.
   *
   * Errors:
   * - InvalidArgument is returned if the request contains an invalid start
   * block.
   * - NotFound is returned if the start block is not currently available on the
   * node. This may happen if the block was from a previous spork,
   * or if the block has yet not been received.
   *
   * @generated from rpc flow.executiondata.ExecutionDataAPI.SubscribeExecutionDataFromStartBlockHeight
   */
  subscribeExecutionDataFromStartBlockHeight: {
    methodKind: "server_streaming"
    input: typeof SubscribeExecutionDataFromStartBlockHeightRequestSchema
    output: typeof SubscribeExecutionDataResponseSchema
  }
  /**
   * SubscribeExecutionDataFromStartBlockHeight streams execution data for all blocks
   * starting from the latest block.
   *
   * Errors:
   * - NotFound is returned if the start block is not currently available on the
   * node. This may happen if the block was from a previous spork,
   * or if the block has yet not been received.
   *
   * @generated from rpc flow.executiondata.ExecutionDataAPI.SubscribeExecutionDataFromLatest
   */
  subscribeExecutionDataFromLatest: {
    methodKind: "server_streaming"
    input: typeof SubscribeExecutionDataFromLatestRequestSchema
    output: typeof SubscribeExecutionDataResponseSchema
  }
  /**
   * Warning: this endpoint is deprecated and will be removed in future versions.
   * Use SubscribeEventsFromStartBlockID, SubscribeEventsFromStartHeight or SubscribeEventsFromLatest.
   *
   * SubscribeEvents streams events for all blocks starting at the requested
   * start block, up until the latest available block. Once the latest is
   * reached, the stream will remain open and responses are sent for each new
   * block as it becomes available.
   *
   * Events within each block are filtered by the provided EventFilter, and only
   * those events that match the filter are returned. If no filter is provided,
   * all events are returned.
   *
   * Responses are returned for each block containing at least one event that
   * matches the filter. Additionally, heartbeat responses
   * (SubscribeEventsResponse with no events) are returned periodically to allow
   * clients to track which blocks were searched. Clients can use this
   * information to determine which block to start from when reconnecting.
   *
   * Errors:
   * - InvalidArgument is returned if the request contains an invalid
   * EventFilter or start block.
   * - NotFound is returned if the start block is not currently available on the
   * node. This may
   *   happen if the block was from a previous spork, or if the block has yet
   *   not been received.
   *
   * @generated from rpc flow.executiondata.ExecutionDataAPI.SubscribeEvents
   * @deprecated
   */
  subscribeEvents: {
    methodKind: "server_streaming"
    input: typeof SubscribeEventsRequestSchema
    output: typeof SubscribeEventsResponseSchema
  }
  /**
   * SubscribeEventsFromStartBlockID streams events for all blocks starting at the requested
   * start block id, up until the latest available block. Once the latest is
   * reached, the stream will remain open and responses are sent for each new
   * block as it becomes available.
   *
   * Events within each block are filtered by the provided EventFilter, and only
   * those events that match the filter are returned. If no filter is provided,
   * all events are returned.
   *
   * Responses are returned for each block containing at least one event that
   * matches the filter. Additionally, heatbeat responses
   * (SubscribeEventsResponse with no events) are returned periodically to allow
   * clients to track which blocks were searched. Clients can use this
   * information to determine which block to start from when reconnecting.
   *
   * Errors:
   * - InvalidArgument is returned if the request contains an invalid block ID or EventFilter.
   * - NotFound is returned if the start block id or execution data are not
   * currently available on the node. This may happen if the block was from a previous spork, or if the
   * block has yet not been received.
   *
   * @generated from rpc flow.executiondata.ExecutionDataAPI.SubscribeEventsFromStartBlockID
   */
  subscribeEventsFromStartBlockID: {
    methodKind: "server_streaming"
    input: typeof SubscribeEventsFromStartBlockIDRequestSchema
    output: typeof SubscribeEventsResponseSchema
  }
  /**
   * SubscribeEventsFromStartHeight streams events for all blocks starting at the requested
   * start block height, up until the latest available block. Once the latest is
   * reached, the stream will remain open and responses are sent for each new
   * block as it becomes available.
   *
   * Events within each block are filtered by the provided EventFilter, and only
   * those events that match the filter are returned. If no filter is provided,
   * all events are returned.
   *
   * Responses are returned for each block containing at least one event that
   * matches the filter. Additionally, heatbeat responses
   * (SubscribeEventsResponse with no events) are returned periodically to allow
   * clients to track which blocks were searched. Clients can use this
   * information to determine which block to start from when reconnecting.
   *
   * Errors:
   * - InvalidArgument is returned if the request contains an invalid EventFilter.
   * - NotFound is returned if the start block height or execution data are not
   * currently available on the node. This may happen if the block was from a previous spork, or if the
   * block has yet not been received.
   *
   * @generated from rpc flow.executiondata.ExecutionDataAPI.SubscribeEventsFromStartHeight
   */
  subscribeEventsFromStartHeight: {
    methodKind: "server_streaming"
    input: typeof SubscribeEventsFromStartHeightRequestSchema
    output: typeof SubscribeEventsResponseSchema
  }
  /**
   * SubscribeEventsFromLatest streams events for all blocks starting from the latest sealed
   * block. The stream will remain open and responses are sent for each new block as it becomes available.
   *
   * Events within each block are filtered by the provided EventFilter, and only
   * those events that match the filter are returned. If no filter is provided,
   * all events are returned.
   *
   * Responses are returned for each block containing at least one event that
   * matches the filter. Additionally, heatbeat responses
   * (SubscribeEventsResponse with no events) are returned periodically to allow
   * clients to track which blocks were searched. Clients can use this
   * information to determine which block to start from when reconnecting.
   *
   * Errors:
   * - InvalidArgument is returned if the request contains an invalid EventFilter.
   *
   * @generated from rpc flow.executiondata.ExecutionDataAPI.SubscribeEventsFromLatest
   */
  subscribeEventsFromLatest: {
    methodKind: "server_streaming"
    input: typeof SubscribeEventsFromLatestRequestSchema
    output: typeof SubscribeEventsResponseSchema
  }
  /**
   * GetRegisterValues gets the values for the given register IDs as of the given block height
   *
   * @generated from rpc flow.executiondata.ExecutionDataAPI.GetRegisterValues
   */
  getRegisterValues: {
    methodKind: "unary"
    input: typeof GetRegisterValuesRequestSchema
    output: typeof GetRegisterValuesResponseSchema
  }
  /**
   * SubscribeAccountStatusesFromStartBlockID streams account statuses for all blocks starting at the requested
   * start block ID, up until the latest available block. Once the latest is
   * reached, the stream will remain open and responses are sent for each new
   * block as it becomes available.
   *
   * Events within each block are filtered by the provided StatusFilter, and only
   * those events that match the filter are returned. If no filter is provided,
   * all events are returned.
   *
   * Responses are returned for each block containing at least one event that
   * matches the filter. Additionally, heartbeat responses
   * (SubscribeAccountStatusesResponse with no events) are returned periodically to allow
   * clients to track which blocks were searched. Clients can use this
   * information to determine which block to start from when reconnecting.
   *
   * Errors:
   * - InvalidArgument is returned if the request contains an invalid
   * StatusFilter or start block.
   * - NotFound is returned if the start block is not currently available on the
   * node. This may happen if the block was from a previous spork, or if the block has yet
   *   not been received.
   *
   * @generated from rpc flow.executiondata.ExecutionDataAPI.SubscribeAccountStatusesFromStartBlockID
   */
  subscribeAccountStatusesFromStartBlockID: {
    methodKind: "server_streaming"
    input: typeof SubscribeAccountStatusesFromStartBlockIDRequestSchema
    output: typeof SubscribeAccountStatusesResponseSchema
  }
  /**
   * SubscribeAccountStatusesFromStartHeight streams account statuses for all blocks starting at the requested
   * start block height, up until the latest available block. Once the latest is
   * reached, the stream will remain open and responses are sent for each new
   * block as it becomes available.
   *
   * Events within each block are filtered by the provided StatusFilter, and only
   * those events that match the filter are returned. If no filter is provided,
   * all events are returned.
   *
   * Responses are returned for each block containing at least one event that
   * matches the filter. Additionally, heartbeat responses
   * (SubscribeAccountStatusesResponse with no events) are returned periodically to allow
   * clients to track which blocks were searched. Clients can use this
   * information to determine which block to start from when reconnecting.
   *
   * Errors:
   * - InvalidArgument is returned if the request contains an invalid
   * StatusFilter or start block.
   * - NotFound is returned if the start block is not currently available on the
   * node. This may happen if the block was from a previous spork, or if the block has yet
   *   not been received.
   *
   * @generated from rpc flow.executiondata.ExecutionDataAPI.SubscribeAccountStatusesFromStartHeight
   */
  subscribeAccountStatusesFromStartHeight: {
    methodKind: "server_streaming"
    input: typeof SubscribeAccountStatusesFromStartHeightRequestSchema
    output: typeof SubscribeAccountStatusesResponseSchema
  }
  /**
   * SubscribeAccountStatusesFromLatestBlock streams account statuses for all blocks starting
   * at the last sealed block, up until the latest available block. Once the latest is
   * reached, the stream will remain open and responses are sent for each new
   * block as it becomes available.
   *
   * Events within each block are filtered by the provided StatusFilter, and only
   * those events that match the filter are returned. If no filter is provided,
   * all events are returned.
   *
   * Responses are returned for each block containing at least one event that
   * matches the filter. Additionally, heartbeat responses
   * (SubscribeAccountStatusesResponse with no events) are returned periodically to allow
   * clients to track which blocks were searched. Clients can use this
   * information to determine which block to start from when reconnecting.
   *
   * Errors:
   * - InvalidArgument is returned if the request contains an invalid
   * StatusFilter or start block.
   * - NotFound is returned if the start block is not currently available on the
   * node. This may happen if the block was from a previous spork, or if the block has yet
   *   not been received.
   *
   * @generated from rpc flow.executiondata.ExecutionDataAPI.SubscribeAccountStatusesFromLatestBlock
   */
  subscribeAccountStatusesFromLatestBlock: {
    methodKind: "server_streaming"
    input: typeof SubscribeAccountStatusesFromLatestBlockRequestSchema
    output: typeof SubscribeAccountStatusesResponseSchema
  }
}> = /*@__PURE__*/ serviceDesc(file_flow_executiondata_executiondata, 0)
